{
  "files": [
    {
      "path": "src/csv_loader.h",
      "code": "#pragma once\n\n#include <string>\n#include <vector>\n\nnamespace sp {\n\nstruct Bar {\n    std::string date;\n    double open;\n    double high;\n    double low;\n    double close;\n    double volume;\n};\n\nclass CSVLoader {\npublic:\n    explicit CSVLoader(const std::string& path);\n\n    // Parse the CSV file specified at construction and return all bars.\n    std::vector<Bar> load() const;\n\nprivate:\n    std::string path_;\n};\n\n} // namespace sp\n"
    },
    {
      "path": "src/csv_loader.cpp",
      "code": "#include \"csv_loader.h\"\n\n#include <fstream>\n#include <sstream>\n#include <stdexcept>\n\nnamespace sp {\n\nCSVLoader::CSVLoader(const std::string& path)\n    : path_(path) {}\n\nstd::vector<Bar> CSVLoader::load() const {\n    std::ifstream file(path_);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Failed to open CSV file: \" + path_);\n    }\n\n    std::vector<Bar> bars;\n    std::string line;\n\n    // Skip header line (assumes the first line is a header)\n    if (!std::getline(file, line)) {\n        return bars; // empty file\n    }\n\n    while (std::getline(file, line)) {\n        if (line.empty()) {\n            continue;\n        }\n        std::stringstream ss(line);\n        Bar bar{};\n        std::string field;\n\n        // date\n        if (!std::getline(ss, bar.date, ',')) {\n            continue; // malformed line\n        }\n\n        // open\n        if (!std::getline(ss, field, ',')) continue;\n        bar.open = std::stod(field);\n\n        // high\n        if (!std::getline(ss, field, ',')) continue;\n        bar.high = std::stod(field);\n\n        // low\n        if (!std::getline(ss, field, ',')) continue;\n        bar.low = std::stod(field);\n\n        // close\n        if (!std::getline(ss, field, ',')) continue;\n        bar.close = std::stod(field);\n\n        // volume\n        if (!std::getline(ss, field, ',')) continue;\n        bar.volume = std::stod(field);\n\n        bars.push_back(bar);\n    }\n\n    return bars;\n}\n\n} // namespace sp\n"
    },
    {
      "path": "src/indicator.h",
      "code": "#pragma once\n\n#include <vector>\n\nnamespace sp {\n\nclass Indicator {\npublic:\n    virtual ~Indicator() = default;\n    virtual std::vector<double> compute(const std::vector<double>& prices) const = 0;\n};\n\nclass SMAIndicator : public Indicator {\npublic:\n    explicit SMAIndicator(int period);\n    std::vector<double> compute(const std::vector<double>& prices) const override;\n\nprivate:\n    int period_;\n};\n\nclass EMAIndicator : public Indicator {\npublic:\n    explicit EMAIndicator(int period);\n    std::vector<double> compute(const std::vector<double>& prices) const override;\n\nprivate:\n    int period_;\n};\n\nclass RSIIndicator : public Indicator {\npublic:\n    explicit RSIIndicator(int period);\n    std::vector<double> compute(const std::vector<double>& prices) const override;\n\nprivate:\n    int period_;\n};\n\nclass MACDIndicator : public Indicator {\npublic:\n    MACDIndicator(int fastPeriod, int slowPeriod);\n    std::vector<double> compute(const std::vector<double>& prices) const override;\n\nprivate:\n    int fastPeriod_;\n    int slowPeriod_;\n};\n\n} // namespace sp\n"
    },
    {
      "path": "src/indicator.cpp",
      "code": "#include \"indicator.h\"\n\n#include <algorithm>\n#include <cmath>\n\nnamespace sp {\n\nSMAIndicator::SMAIndicator(int period)\n    : period_(period) {}\n\nstd::vector<double> SMAIndicator::compute(const std::vector<double>& prices) const {\n    std::vector<double> result(prices.size(), 0.0);\n    if (period_ <= 0 || static_cast<std::size_t>(period_) > prices.size()) {\n        return result;\n    }\n\n    double windowSum = 0.0;\n    for (int i = 0; i < period_; ++i) {\n        windowSum += prices[static_cast<std::size_t>(i)];\n    }\n    result[static_cast<std::size_t>(period_ - 1)] = windowSum / static_cast<double>(period_);\n\n    for (std::size_t i = static_cast<std::size_t>(period_); i < prices.size(); ++i) {\n        windowSum += prices[i];\n        windowSum -= prices[i - static_cast<std::size_t>(period_)];\n        result[i] = windowSum / static_cast<double>(period_);\n    }\n\n    return result;\n}\n\nEMAIndicator::EMAIndicator(int period)\n    : period_(period) {}\n\nstd::vector<double> EMAIndicator::compute(const std::vector<double>& prices) const {\n    std::vector<double> result(prices.size(), 0.0);\n    if (period_ <= 0 || prices.empty()) {\n        return result;\n    }\n\n    const double alpha = 2.0 / (static_cast<double>(period_) + 1.0);\n\n    result[0] = prices[0];\n    for (std::size_t i = 1; i < prices.size(); ++i) {\n        result[i] = alpha * prices[i] + (1.0 - alpha) * result[i - 1];\n    }\n\n    return result;\n}\n\nRSIIndicator::RSIIndicator(int period)\n    : period_(period) {}\n\nstd::vector<double> RSIIndicator::compute(const std::vector<double>& prices) const {\n    const std::size_t n = prices.size();\n    std::vector<double> result(n, 50.0);\n    if (period_ <= 0 || n <= 1 || static_cast<std::size_t>(period_) >= n) {\n        return result;\n    }\n\n    double avgGain = 0.0;\n    double avgLoss = 0.0;\n\n    for (int i = 1; i <= period_; ++i) {\n        const double change = prices[static_cast<std::size_t>(i)] - prices[static_cast<std::size_t>(i - 1)];\n        if (change > 0.0) {\n            avgGain += change;\n        } else {\n            avgLoss -= change;\n        }\n    }\n    avgGain /= static_cast<double>(period_);\n    avgLoss /= static_cast<double>(period_);\n\n    for (std::size_t i = static_cast<std::size_t>(period_ + 1); i < n; ++i) {\n        const double change = prices[i] - prices[i - 1];\n        const double gain = change > 0.0 ? change : 0.0;\n        const double loss = change < 0.0 ? -change : 0.0;\n\n        avgGain = ((static_cast<double>(period_ - 1) * avgGain) + gain) / static_cast<double>(period_);\n        avgLoss = ((static_cast<double>(period_ - 1) * avgLoss) + loss) / static_cast<double>(period_);\n\n        double rs = 0.0;\n        if (avgLoss == 0.0) {\n            rs = 100.0; // practically infinite relative strength\n        } else {\n            rs = avgGain / avgLoss;\n        }\n\n        result[i] = 100.0 - (100.0 / (1.0 + rs));\n    }\n\n    return result;\n}\n\nMACDIndicator::MACDIndicator(int fastPeriod, int slowPeriod)\n    : fastPeriod_(fastPeriod), slowPeriod_(slowPeriod) {}\n\nstd::vector<double> MACDIndicator::compute(const std::vector<double>& prices) const {\n    std::vector<double> result(prices.size(), 0.0);\n    if (fastPeriod_ <= 0 || slowPeriod_ <= 0 || prices.empty()) {\n        return result;\n    }\n\n    EMAIndicator fast(fastPeriod_);\n    EMAIndicator slow(slowPeriod_);\n    std::vector<double> fastLine = fast.compute(prices);\n    std::vector<double> slowLine = slow.compute(prices);\n\n    const std::size_t n = prices.size();\n    for (std::size_t i = 0; i < n; ++i) {\n        result[i] = fastLine[i] - slowLine[i];\n    }\n\n    return result;\n}\n\n} // namespace sp\n"
    },
    {
      "path": "src/strategy.h",
      "code": "#pragma once\n\n#include \"csv_loader.h\"\n#include \"indicator.h\"\n\n#include <memory>\n#include <vector>\n\nnamespace sp {\n\nclass Strategy {\npublic:\n    virtual ~Strategy() = default;\n    virtual std::vector<int> generate_signals(const std::vector<Bar>& bars) const = 0;\n};\n\nclass RuleBasedStrategy : public Strategy {\npublic:\n    RuleBasedStrategy(std::shared_ptr<Indicator> fastIndicator,\n                      std::shared_ptr<Indicator> slowIndicator);\n\n    std::vector<int> generate_signals(const std::vector<Bar>& bars) const override;\n\nprivate:\n    std::shared_ptr<Indicator> fastIndicator_;\n    std::shared_ptr<Indicator> slowIndicator_;\n};\n\n} // namespace sp\n"
    },
    {
      "path": "src/strategy.cpp",
      "code": "#include \"strategy.h\"\n\nnamespace sp {\n\nRuleBasedStrategy::RuleBasedStrategy(std::shared_ptr<Indicator> fastIndicator,\n                                     std::shared_ptr<Indicator> slowIndicator)\n    : fastIndicator_(std::move(fastIndicator)),\n      slowIndicator_(std::move(slowIndicator)) {}\n\nstd::vector<int> RuleBasedStrategy::generate_signals(const std::vector<Bar>& bars) const {\n    const std::size_t n = bars.size();\n    std::vector<int> signals(n, 0);\n    if (n == 0 || !fastIndicator_ || !slowIndicator_) {\n        return signals;\n    }\n\n    std::vector<double> closes;\n    closes.reserve(n);\n    for (const auto& bar : bars) {\n        closes.push_back(bar.close);\n    }\n\n    std::vector<double> fastVals = fastIndicator_->compute(closes);\n    std::vector<double> slowVals = slowIndicator_->compute(closes);\n\n    bool inLong = false;\n    for (std::size_t i = 0; i < n; ++i) {\n        const double f = fastVals[i];\n        const double s = slowVals[i];\n\n        if (!inLong && f > s) {\n            inLong = true;\n            signals[i] = 1;\n        } else if (inLong && f <= s) {\n            inLong = false;\n            signals[i] = 0; // explicit flat signal (used by backtester to exit)\n        } else {\n            // maintain previous state: if inLong, keep 1; if flat, keep 0\n            signals[i] = inLong ? 1 : 0;\n        }\n    }\n\n    return signals;\n}\n\n} // namespace sp\n"
    },
    {
      "path": "src/backtester.h",
      "code": "#pragma once\n\n#include \"csv_loader.h\"\n\n#include <string>\n#include <vector>\n\nnamespace sp {\n\nstruct Trade {\n    std::string entry_date;\n    std::string exit_date;\n    double entry_price;\n    double exit_price;\n    int size;\n    double pnl;\n};\n\nclass Backtester {\npublic:\n    Backtester(double initialCapital = 10000.0,\n               double slippage = 0.0,\n               double cost = 0.0);\n\n    void run(const std::vector<Bar>& bars, const std::vector<int>& signals);\n\n    const std::vector<double>& equity() const { return equity_; }\n    const std::vector<Trade>& trades() const { return trades_; }\n\nprivate:\n    double initialCapital_;\n    double slippage_;\n    double cost_;\n\n    std::vector<double> equity_;\n    std::vector<Trade> trades_;\n};\n\n} // namespace sp\n"
    },
    {
      "path": "src/backtester.cpp",
      "code": "#include \"backtester.h\"\n\n#include <cmath>\n\nnamespace sp {\n\nBacktester::Backtester(double initialCapital, double slippage, double cost)\n    : initialCapital_(initialCapital),\n      slippage_(slippage),\n      cost_(cost) {}\n\nvoid Backtester::run(const std::vector<Bar>& bars, const std::vector<int>& signals) {\n    equity_.clear();\n    trades_.clear();\n\n    const std::size_t n = bars.size();\n    if (n == 0 || signals.size() != n) {\n        return;\n    }\n\n    double cash = initialCapital_;\n    int positionSize = 0;\n    double entryPrice = 0.0;\n    std::string entryDate;\n\n    for (std::size_t i = 0; i < n; ++i) {\n        const double price = bars[i].close;\n        const int signal = signals[i];\n\n        const bool wantLong = (signal == 1);\n        const bool inLong = (positionSize > 0);\n\n        if (!inLong && wantLong) {\n            const double adjEntryPrice = price * (1.0 + slippage_);\n            if (adjEntryPrice > 0.0) {\n                int size = static_cast<int>(std::floor(cash / adjEntryPrice));\n                if (size > 0) {\n                    positionSize = size;\n                    entryPrice = adjEntryPrice;\n                    entryDate = bars[i].date;\n                    cash -= static_cast<double>(positionSize) * entryPrice;\n                }\n            }\n        } else if (inLong && !wantLong) {\n            const double adjExitPrice = price * (1.0 - slippage_);\n            const double gross = static_cast<double>(positionSize) * adjExitPrice;\n            const double tradePnl = gross - static_cast<double>(positionSize) * entryPrice - cost_;\n\n            Trade t{};\n            t.entry_date = entryDate;\n            t.exit_date = bars[i].date;\n            t.entry_price = entryPrice;\n            t.exit_price = adjExitPrice;\n            t.size = positionSize;\n            t.pnl = tradePnl;\n            trades_.push_back(t);\n\n            cash += gross;\n            positionSize = 0;\n            entryPrice = 0.0;\n            entryDate.clear();\n        }\n\n        double equityNow = cash + static_cast<double>(positionSize) * price;\n        equity_.push_back(equityNow);\n    }\n\n    if (positionSize > 0 && !bars.empty()) {\n        const double price = bars.back().close;\n        const double adjExitPrice = price * (1.0 - slippage_);\n        const double gross = static_cast<double>(positionSize) * adjExitPrice;\n        const double tradePnl = gross - static_cast<double>(positionSize) * entryPrice - cost_;\n\n        Trade t{};\n        t.entry_date = entryDate;\n        t.exit_date = bars.back().date;\n        t.entry_price = entryPrice;\n        t.exit_price = adjExitPrice;\n        t.size = positionSize;\n        t.pnl = tradePnl;\n        trades_.push_back(t);\n\n        cash += gross;\n        positionSize = 0;\n        entryPrice = 0.0;\n        entryDate.clear();\n\n        if (!equity_.empty()) {\n            equity_.back() = cash;\n        }\n    }\n}\n\n} // namespace sp\n"
    },
    {
      "path": "src/metrics.h",
      "code": "#pragma once\n\n#include \"backtester.h\"\n\nnamespace sp {\n\nstruct Metrics {\n    double final_equity{0.0};\n    double max_drawdown{0.0};\n    int total_trades{0};\n    int winning_trades{0};\n};\n\nMetrics compute_metrics(const std::vector<double>& equity,\n                        const std::vector<Trade>& trades,\n                        double initialCapital = 10000.0);\n\n} // namespace sp\n"
    },
    {
      "path": "src/metrics.cpp",
      "code": "#include \"metrics.h\"\n\n#include <algorithm>\n\nnamespace sp {\n\nMetrics compute_metrics(const std::vector<double>& equity,\n                        const std::vector<Trade>& trades,\n                        double /*initialCapital*/) {\n    Metrics m{};\n\n    if (!equity.empty()) {\n        m.final_equity = equity.back();\n    }\n\n    m.total_trades = static_cast<int>(trades.size());\n    m.winning_trades = 0;\n    for (const auto& t : trades) {\n        if (t.pnl > 0.0) {\n            ++m.winning_trades;\n        }\n    }\n\n    if (!equity.empty()) {\n        double peak = equity.front();\n        double maxDD = 0.0;\n        for (double e : equity) {\n            if (e > peak) {\n                peak = e;\n            }\n            if (peak > 0.0) {\n                const double dd = (peak - e) / peak;\n                if (dd > maxDD) {\n                    maxDD = dd;\n                }\n            }\n        }\n        m.max_drawdown = maxDD;\n    }\n\n    return m;\n}\n\n} // namespace sp\n"
    },
    {
      "path": "src/main.cpp",
      "code": "#include \"backtester.h\"\n#include \"csv_loader.h\"\n#include \"indicator.h\"\n#include \"metrics.h\"\n#include \"strategy.h\"\n\n#include <cstdlib>\n#include <exception>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n\nint main(int argc, char* argv[]) {\n    using namespace sp;\n\n    if (argc < 2) {\n        std::cerr << \"Usage: \" << argv[0]\n                  << \" <csv_file> [--sma N] [--ema M] [--slippage S] [--initial-capital C]\\n\";\n        return 1;\n    }\n\n    std::string csvPath = argv[1];\n    int smaPeriod = 20;\n    int emaPeriod = 10;\n    double slippage = 0.0;\n    double initialCapital = 10000.0;\n\n    for (int i = 2; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--sma\" && i + 1 < argc) {\n            smaPeriod = std::atoi(argv[++i]);\n        } else if (arg == \"--ema\" && i + 1 < argc) {\n            emaPeriod = std::atoi(argv[++i]);\n        } else if (arg == \"--slippage\" && i + 1 < argc) {\n            slippage = std::atof(argv[++i]);\n        } else if (arg == \"--initial-capital\" && i + 1 < argc) {\n            initialCapital = std::atof(argv[++i]);\n        }\n    }\n\n    try {\n        CSVLoader loader(csvPath);\n        std::vector<Bar> bars = loader.load();\n        if (bars.empty()) {\n            std::cerr << \"No data loaded from: \" << csvPath << \"\\n\";\n            return 1;\n        }\n\n        std::shared_ptr<Indicator> sma = std::make_shared<SMAIndicator>(smaPeriod);\n        std::shared_ptr<Indicator> ema = std::make_shared<EMAIndicator>(emaPeriod);\n\n        RuleBasedStrategy strategy(ema, sma);\n        std::vector<int> signals = strategy.generate_signals(bars);\n\n        Backtester backtester(initialCapital, slippage, 0.0);\n        backtester.run(bars, signals);\n\n        Metrics m = compute_metrics(backtester.equity(), backtester.trades(), initialCapital);\n\n        std::cout << \"Trades: \" << m.total_trades\n                  << \" Wins: \" << m.winning_trades\n                  << \" Final equity: \" << m.final_equity\n                  << \" MaxDD: \" << m.max_drawdown << \"\\n\";\n\n        const auto& trades = backtester.trades();\n        for (std::size_t i = 0; i < trades.size(); ++i) {\n            const Trade& t = trades[i];\n            std::cout << \"Trade \" << i\n                      << \": \" << t.entry_date << \" -> \" << t.exit_date\n                      << \" size=\" << t.size\n                      << \" entry=\" << t.entry_price\n                      << \" exit=\" << t.exit_price\n                      << \" pnl=\" << t.pnl\n                      << \"\\n\";\n        }\n\n    } catch (const std::exception& ex) {\n        std::cerr << \"Error: \" << ex.what() << \"\\n\";\n        return 1;\n    }\n\n    return 0;\n}\n"
    }
  ]
}
